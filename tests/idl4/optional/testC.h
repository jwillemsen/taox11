/**
 * ****  Code generated by the RIDL Compiler ****
 * RIDL has been developed by:
 *        Remedy IT Expertise BV
 *        The Netherlands
 *        https://www.remedy.nl
 */

#ifndef __RIDL_TESTC_H_BIHDABDA_INCLUDED__
#define __RIDL_TESTC_H_BIHDABDA_INCLUDED__

#pragma once

#include /**/ "tao/x11/base/pre.h"
#include "tao/x11/base/stddef.h"
#include "tao/x11/base/basic_traits.h"
#include "tao/x11/corba.h"
#include "tao/x11/optional_t.h"

#include /**/ "tao/x11/base/versionx11.h"

#if TAOX11_MAJOR_VERSION != 2 || TAOX11_MINOR_VERSION != 6 || TAOX11_MICRO_VERSION != 0
#error This file was generated with another RIDL C++11 backend version (2.6.0). Please re-generate.
#endif

using namespace TAOX11_NAMESPACE;

// generated from c++11/templates/cli/hdr/struct_pre
/// @copydoc test.idl::bar
class bar
{
public:
  // generated from c++11/templates/cli/hdr/struct_post
  bar () = default;
  ~bar () = default;
  bar (const bar&) = default;
  bar (bar&&) = default;
  /// Constructor which accepts value for all members
  explicit inline bar (
    int16_t x,
    IDL::optional<int16_t> z,
    int32_t z_long,
    IDL::optional<int16_t> a,
    IDL::optional<std::string> opt_string,
    std::string y);
  bar& operator= (const bar&) = default;
  bar& operator= (bar&&) = default;

  /// @copydoc test.idl::bar::x
  //@{
  inline void x (int16_t _x11_x) { this->x_ = _x11_x; }
  inline int16_t x () const { return this->x_; }
  inline int16_t& x () { return this->x_; }
  //@}

  /// @copydoc test.idl::bar::z
  //@{
  inline void z (const IDL::optional<int16_t>& _x11_z) { this->z_ = _x11_z; }
  inline void z (IDL::optional<int16_t>&& _x11_z) { this->z_ = std::move (_x11_z); }
  inline const IDL::optional<int16_t>& z () const { return this->z_; }
  inline IDL::optional<int16_t>& z () { return this->z_; }
  //@}

  /// @copydoc test.idl::bar::z_long
  //@{
  inline void z_long (int32_t _x11_z_long) { this->z_long_ = _x11_z_long; }
  inline int32_t z_long () const { return this->z_long_; }
  inline int32_t& z_long () { return this->z_long_; }
  //@}

  /// @copydoc test.idl::bar::a
  //@{
  inline void a (const IDL::optional<int16_t>& _x11_a) { this->a_ = _x11_a; }
  inline void a (IDL::optional<int16_t>&& _x11_a) { this->a_ = std::move (_x11_a); }
  inline const IDL::optional<int16_t>& a () const { return this->a_; }
  inline IDL::optional<int16_t>& a () { return this->a_; }
  //@}

  /// @copydoc test.idl::bar::opt_string
  //@{
  inline void opt_string (const IDL::optional<std::string>& _x11_opt_string) { this->opt_string_ = _x11_opt_string; }
  inline void opt_string (IDL::optional<std::string>&& _x11_opt_string) { this->opt_string_ = std::move (_x11_opt_string); }
  inline const IDL::optional<std::string>& opt_string () const { return this->opt_string_; }
  inline IDL::optional<std::string>& opt_string () { return this->opt_string_; }
  //@}

  /// @copydoc test.idl::bar::y
  //@{
  inline void y (const std::string& _x11_y) { this->y_ = _x11_y; }
  inline void y (std::string&& _x11_y) { this->y_ = std::move (_x11_y); }
  inline const std::string& y () const { return this->y_; }
  inline std::string& y () { return this->y_; }
  //@}

  /// Exchange the value of two structures in an efficient matter
  inline void swap (bar& s);

private:
  int16_t x_{};
  IDL::optional<int16_t> z_{std::nullopt};
  int32_t z_long_{};
  IDL::optional<int16_t> a_{std::nullopt};
  IDL::optional<std::string> opt_string_{std::nullopt};
  std::string y_{};
};// bar

inline void swap (::bar& m1, ::bar& m2) { m1.swap (m2); }

// generated from StubHeaderIDLTraitsWriter#pre_visit
namespace TAOX11_NAMESPACE::IDL
{

  // generated from c++11/templates/cli/hdr/struct_idl_traits
#if !defined (_STRUCT_BAR_TRAITS_)
#define _STRUCT_BAR_TRAITS_
  template<>
  struct traits <::bar>
    : IDL::common_traits<::bar>
  {
    template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
    static inline OStrm_& write_on(OStrm_& os_, in_type val_, Formatter fmt_ = Formatter ())
    {
      return fmt_ (os_, val_);
    }

    template <typename Formatter = std::false_type>
    static inline __Writer<Formatter> write (in_type val) { return {val}; }
  };

  template <typename OStrm_>
  struct formatter<::bar, OStrm_>;

  template <typename OStrm_, typename Fmt>
  OStrm_& operator <<(OStrm_&, IDL::traits<::bar>::__Writer<Fmt>);

  template<>
  struct traits <IDL::optional<int16_t>>
    : IDL::common_traits<IDL::optional<int16_t>>
  {
    template <typename OStrm_, typename Formatter = formatter<value_type, OStrm_>>
    static inline OStrm_& write_on(OStrm_& os_, in_type val_, Formatter fmt_ = Formatter ())
    {
      return fmt_ (os_, val_);
    }

    template <typename Formatter = std::false_type>
    static inline __Writer<Formatter> write (in_type val) { return {val}; }
  };

  template <typename OStrm_, typename Fmt>
  OStrm_& operator <<(OStrm_&, IDL::traits<IDL::optional<int16_t>>::__Writer<Fmt>);
  #endif // _STRUCT_BAR_TRAITS_
} // namespace TAOX11_NAMESPACE::IDL

// generated from StubHeaderIDLTraitsDefWriter#pre_visit
namespace TAOX11_NAMESPACE::IDL
{


  template <typename OStrm_, typename Fmt>
  inline OStrm_& operator <<(OStrm_& os, IDL::traits<IDL::optional<int16_t>>::__Writer<Fmt> w)
  {
    using writer_t = IDL::traits<IDL::optional<int16_t>>::__Writer<Fmt>;
    using formatter_t = typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter<IDL::optional<int16_t>, OStrm_>,
                          typename writer_t::formatter_t>::type;
    return IDL::traits<IDL::optional<int16_t>>::write_on (os, w.val_, formatter_t ());
  }

  // generated from c++11/templates/cli/hdr/struct_idl_traits_def
  template <typename OStrm_>
  struct formatter<::bar, OStrm_>
  {
    inline OStrm_& operator ()(
        OStrm_& os_,
        const ::bar& val_)
    {
      os_ << "bar"
          << '{'
          << "x=" << IDL::traits<int16_t>::write(val_.x ())
          << ",z=" << IDL::traits<IDL::optional<int16_t>>::write(val_.z ())
          << ",z_long=" << IDL::traits<int32_t>::write(val_.z_long ())
          << ",a="; if (val_.a ().has_value ()) { os_ << IDL::traits<int16_t>::write(val_.a ().value ()); } else { os_ << "std::nullopt"; } os_
          << ",opt_string="; if (val_.opt_string ().has_value ()) { os_ << IDL::traits<std::string>::write(val_.opt_string ().value ()); } else { os_ << "std::nullopt"; } os_
          << ",y=" << IDL::traits<std::string>::write(val_.y ())
          << '}';
      return os_;
    }
  };

  template <typename OStrm_, typename Fmt>
  inline OStrm_& operator <<(OStrm_& os, IDL::traits<::bar>::__Writer<Fmt> w)
  {
    using writer_t = IDL::traits<::bar>::__Writer<Fmt>;
    using formatter_t = typename std::conditional<
                          std::is_same<
                            typename writer_t::formatter_t,
                            std::false_type>::value,
                          formatter<::bar, OStrm_>,
                          typename writer_t::formatter_t>::type;
    return IDL::traits<::bar>::write_on (os, w.val_, formatter_t ());
  }
} // namespace TAOX11_NAMESPACE::IDL

// generated from c++11/templates/cli/inl/struct_inl
inline ::bar::bar (
  int16_t x,
  IDL::optional<int16_t> z,
  int32_t z_long,
  IDL::optional<int16_t> a,
  IDL::optional<std::string> opt_string,
  std::string y)
  : x_ (std::move (x))
  , z_ (std::move (z))
  , z_long_ (std::move (z_long))
  , a_ (std::move (a))
  , opt_string_ (std::move (opt_string))
  , y_ (std::move (y))
{
}

inline void ::bar::swap (::bar& s)
{
  std::swap (this->x_, s.x_);
  std::swap (this->z_, s.z_);
  std::swap (this->z_long_, s.z_long_);
  std::swap (this->a_, s.a_);
  std::swap (this->opt_string_, s.opt_string_);
  std::swap (this->y_, s.y_);
}

// generated from c++11/templates/cli/hdr/struct_os
inline std::ostream& operator<< (std::ostream& strm, const ::bar& _v)
{
  return IDL::traits<::bar>::write_on (strm, _v);
}

// generated from c++11/templates/cli/hdr/post
#if !defined (TAOX11_DISABLE_INCLUDE_STUB_PROXY_HDR) && defined (__TAOX11_INCLUDE_STUB_PROXY__) && __has_include("testCP.h")
# include "testCP.h"
#endif

#include /**/ "tao/x11/base/post.h"

#endif /* __RIDL_TESTC_H_BIHDABDA_INCLUDED__ */

// -*- END -*-
